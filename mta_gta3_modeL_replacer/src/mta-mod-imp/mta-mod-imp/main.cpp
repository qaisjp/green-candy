/*
	GTA model importer creator for mtasa dm.
	This executable creates files which are needed due to limitation of mtasa dm.
	Created by The_GTA
*/
#include "main.h"

CIPL *ipls[256];
unsigned int numIPL = 0;
CIDE *ides[256];
unsigned int numIDE = 0;
bool avalID[65536];

instanceList_t instances;
objectList_t objects;

#define MAP_LUA 1
#define MAP_XML 2
#define MAP_METHOD MAP_XML
#define MAP_MAXLOD TRUE

#define MODEL_TABLE 1
#define MODEL_STATIC 2
#define MODEL_METHOD MODEL_TABLE

#define LUA_DOCOMPILE TRUE

const char *pLuaHeader=
	"-- File generated by MTASA model importer\n" \
	"local streamedObjects = {};\n" \
	"local pModels = {};\n\n" \
	"setCloudsEnabled(false);\n" \
	"setFarClipDistance(350);\n" \
	"setFogDistance(10);\n" \
	"setPedFrozen(getLocalPlayer(), true);\n\n" \
	"function modelStreamOut ()\n" \
	"	local pModel = pModels[getElementModel(source)];\n\n" \
	"	if not (pModel) then return end;\n\n" \
	"	pModel.numStream = pModel.numStream - 1;\n\n" \
	"	if (pModel.numStream == 0) then\n" \
	"		engineRestoreCOL(getElementModel(source));\n" \
	"		engineRestoreModel(getElementModel(source));\n" \
	"	end\n" \
	"end\n\n" \
	"function modelStreamIn ()\n" \
	"	local pModel = pModels[getElementModel(source)];\n\n" \
	"	if not (pModel) then return end;\n\n" \
	"	pModel.numStream = pModel.numStream + 1;\n\n" \
	"	if not (pModel.numStream == 1) then return end;\n\n" \
	"	pModel.isRequesting = false;\n\n" \
	"	if not (pModel.model) then\n" \
	"		outputDebugString(\"model missing \" .. pModel.name);\n" \
	"		return false;\n" \
	"	end\n\n" \
	"	engineReplaceModel(pModel.model, getElementModel(source));\n\n" \
	"	if not (pModel.col) then\n" \
	"		outputDebugString(\"missing collision for \" .. pModel.name);\n" \
	"		return true;\n" \
	"	end\n\n" \
	"	engineReplaceCOL(pModel.col, getElementModel(source));\n" \
	"end\n\n" \
	"function loadModels ()\n" \
	"	local pModel, pTXD, pColl, pTable;\n\n";
#if (MODEL_METHOD == MODEL_STATIC)
const char *pLuaEntry=
	"	pModel=engineLoadDFF(\"models/%s.dff\",0);\n" \
	"	pModels[%u]={};\n" \
	"	pTable=pModels[%u];\n" \
	"	pColl=engineLoadCOL(\"coll/%s.col\");\n" \
	"	pModels[%u].col=pColl;\n" \
	"	pModels[%u].lod=500;\n" \
	"	engineImportTXD(pTXD,%u);\n" \
	"	pTable.numStream=0;\n" \
	"	pTable.model=pModel;\n";
#elif (MODEL_METHOD==MODEL_TABLE)
const char *pLuaModelTableBegin=
	"	pTable={\n";
const char *pLuaModelTableEntry=
	"		{ model=%u, model_file=\"%s\", txd_file=\"%s\", coll_file=\"%s\", lod=%s }";
const char *pLuaModelTableSeperator=
	",\n";
const char *pLuaModelTableEnd=
	"	};\n\n";
const char *pLuaModelTableLoad=
	"	local n,m;\n\n" \
	"	for n,m in ipairs(pTable) do\n" \
	"		pModels[m.model]={};\n" \
	"		pModelEntry=pModels[m.model];\n" \
	"		pModelEntry.name = m.model_file;\n" \
	"		pModelEntry.txd=engineLoadTXD(\"textures/\"..m.txd_file..\".txd\");\n" \
	"		engineImportTXD(pModelEntry.txd, n);\n" \
	"		pModelEntry.model=engineLoadDFF(\"models/\"..m.model_file..\".dff\",0);\n" \
	"		pModelEntry.col=engineLoadCOL(\"coll/\"..m.coll_file..\".col\");\n" \
	"		pModelEntry.numStream=0;\n" \
	"		pModelEntry.lod=m.lod;\n" \
	"		engineSetModelLODDistance(m.model, m.lod);\n" \
	"	end;\n";
#endif
const char *pLuaEnd=
	"end\n" \
	"loadModels();\n\n" \
	"addEventHandler(\"onClientElementStreamIn\", resourceRoot, function()\n" \
	"		local pModel = pModels[getElementModel(source)];\n\n" \
	"		if not (pModel.isRequesting) then return true; end;\n\n" \
	"		if not (pModel.isRequesting == 2) or not (pModel.requestObj == source) then return true; end;\n\n" \
	"		pModel.isRequesting = false;\n" \
	"		outputDebugString(\"requested collisions for \" .. pModel.name);\n\n" \
	"		if not (pModel.col) then\n" \
	"			outputDebugString(\"missing collision (\" .. pModel.name .. \")\");\n" \
	"			return true;\n" \
	"		end\n\n" \
	"		engineReplaceCOL(pModel.col, getElementModel(source));\n" \
	"		engineSetModelLODDistance(getElementModel(source), pModel.lod);\n" \
	"	end\n" \
	");\n\n" \
	"addEventHandler(\"onClientElementStreamOut\", resourceRoot, function()\n" \
	"		local pModel = pModels[getElementModel(source)];\n\n" \
	"		if not (pModel.isRequesting) or not (pModel.requestObj == source) then return true; end;\n\n" \
	"		pModel.isRequesting = 2;\n" \
	"	end\n" \
	");\n\n" \
	"addEventHandler(\"onClientPreRender\", root, function()\n" \
	"		local m,n;\n" \
	"		local objects = getElementsByType(\"object\");\n" \
	"		local x, y, z = getElementPosition(localPlayer);\n\n" \
	"		for m,n in ipairs(objects) do\n" \
	"			local model = pModels[getElementModel(n)];\n\n" \
	"			if (model) then\n" \
	"				local streamObject = streamedObjects[n];\n" \
	"				local distance = getDistanceBetweenPoints3D(x, y, z, getElementPosition(n));\n\n" \
	"				if not (streamObject) then\n" \
	"					if (distance < model.lod) then\n" \
	"						source = n;\n\n" \
	"						modelStreamIn();\n\n" \
	"						streamedObjects[n] = n;\n" \
	"					end\n" \
	"				elseif (distance > model.lod) then\n" \
	"					source = n;\n\n" \
	"					modelStreamOut();\n\n" \
	"					streamedObjects[n] = nil;\n" \
	"				end\n" \
	"			end\n" \
	"		end\n" \
	"	end\n" \
	");\n\n" \
	"addEventHandler(\"onClientResourceStop\", resourceRoot, function()\n" \
	"		disableRequests = true;\n\n" \
	"		for m,n in pairs(pModels) do\n" \
	"			if (isElement(n.txd)) then destroyElement(n.txd); end\n" \
	"			if (isElement(n.col)) then destroyElement(n.col); end\n" \
	"			if (isElement(n.model)) then destroyElement(n.model); end\n" \
	"			engineRestoreCOL(m);\n" \
	"			engineRestoreModel(m);\n" \
	"		end\n" \
	"	end\n" \
	");\n\n" \
	"setPedFrozen(getLocalPlayer(), false);\n" \
	"setJetpackMaxHeight(1000);\n";
const char *pServerHeader=
	"-- Automatically generated server script by MTASA map IPL map converter\n" \
	"setMapName(\"United\");\n";
#if (MAP_METHOD==MAP_LUA)
const char *pServerMapHeader=
	"function loadMap ()\n" \
	"	local pObj;\n\n";
const char *pServerMapEntry=
	"	pObj=createObject(%u,%f,%f,%f);\n" \
	"	setElementID(pObj,\"%s\");\n";
const char *pServerMapEntry2=
	"	setObjectRotation(pObj,%u,%u,%u);\n";
const char *pServerMapEnd=
	"end;\n" \
	"loadMap();\n";
#endif
const char *pServerEnd=
	"-- The end\n";
#if (MAP_METHOD==MAP_XML)
const char *pMapHeader=
	"<map edf:definitions=\"editor_main\">\n";
const char *pMapEntry=
	"	<object id=\"%s\" dimension=\"0\" interior=\"0\" model=\"%u\" posX=\"%f\" posY=\"%f\" posZ=\"%f\" ";
const char *pMapEntry2=
	"rotX=\"%u\" rotY=\"%u\" rotZ=\"%u\" />\n";
char *pMapEnd=
	"</map>\n";
#endif
const char *pMetaHeader=
	"<meta>\n" \
	"	<info author=\"The_GTA\" description=\"Automatically generated map file by MTASA map converter\" version=\"1.0\" type=\"map\" />\n";
#if (MAP_METHOD==MAP_XML)
const char *pMetaHeaderMap=
	"	<map src=\"gta3.map\" />\n";
#endif
const char *pMetaHeader2=
	"	<script src=\"%s\" type=\"client\" />\n" \
	"	<script src=\"main_server.lua\" type=\"server\" />\n";
const char *pMetaEntryTXD=
	"	<file src=\"models\\%s.dff\" type=\"client\" />\n" \
	"	<file src=\"coll\\%s.col\" type=\"client\" />\n" \
	"	<file src=\"textures\\%s.txd\" type=\"client\" />\n";
const char *pMetaEntry=
	"	<file src=\"models\\%s.dff\" type=\"client\" />\n" \
	"	<file src=\"coll\\%s.col\" type=\"client\" />\n";
const char *pMetaEnd=
	"</meta>\n";

short usYoffset=0;
short usXoffset=0;
short usZoffset=500;

bool FileExists(const char *fileName)
{
    return (GetFileAttributes(fileName) != 0xFFFFFFFF);
}

CObject*	GetObjectByModel(const char *model)
{
	objectList_t::iterator iter;

	for (iter = objects.begin(); iter != objects.end(); iter++)
		if (strcmp((*iter)->m_modelName, model) == 0)
			return *iter;
	
	return NULL;
}

// Process data
void	LoadTargetIPL(const char *filename)
{
	unsigned int numInst = -1;
#ifdef _SAME_NAME_METHOD
	char buffer[1024];
	CIDE *ide;
	objectList_t::iterator iter;
#endif
	CIPL *ipl;
	instanceList_t::iterator i_iter;

	ipl = LoadIPL(filename);

	for (i_iter = ipl->m_instances.begin(); i_iter != ipl->m_instances.end(); i_iter++)
	{
		numInst++;

		if (ipl->IsLOD(numInst))
			continue;

		instances.push_back(*i_iter);
	}

	ipls[numIPL++] = ipl;

#ifdef _SAME_NAME_METHOD
	strncpy(buffer, filename, strlen(filename) - 3);
	buffer[strlen(filename) - 3] = 0;
	strcat(buffer, "ide");

	if (!(ide = LoadIDE(buffer)))
	{
		printf("could not find '%s' file!", buffer);
		getchar();

		exit(EXIT_FAILURE);
	}

	for (iter = ide->m_objects.begin(); iter != ide->m_objects.end(); iter++)
		objects.push_back(*iter);
#endif
}

#ifndef _SAME_NAME_METHOD
void	LoadTargetIDE(const char *name)
{
	CIDE *ide = LoadIDE(name);
	objectList_t::iterator iter;

	if (!ide)
	{
		printf("could not load '%s' file!", name);
		getchar();

		exit(EXIT_FAILURE);
	}

	for (iter = ide->m_objects.begin(); iter != ide->m_objects.end(); iter++)
		objects.push_back(*iter);
}
#endif

void	LoadReplaceIDE(const char *filename)
{
	CIDE *ide = LoadIDE(filename);
	objectList_t::iterator iter;

	// Marks all ids as available
	for (iter = ide->m_objects.begin(); iter != ide->m_objects.end(); iter++)
	{
		//if ((*iter)->m_flags & (OBJECT_ALPHA1 | OBJECT_ALPHA2 | OBJECT_NOCULL | OBJECT_BREAKGLASS | OBJECT_BREAKGLASS_CRACK | OBJECT_GARAGE | OBJECT_MULTICLUMP | OBJECT_USE_POLYSHADOW | OBJECT_EXPLOSIVE | OBJECT_UNKNOWN | OBJECT_UNKNOWN_2 | OBJECT_GRAFFITI | OBJECT_NOBACKFACECULL | OBJECT_STATUE | OBJECT_UNKNOWN_HIGH))
		if ((*iter)->m_flags != 0 && !((*iter)->m_flags & OBJECT_INTERIOR))
			continue;

		avalID[(*iter)->m_modelID] = true;
	}

	delete ide;
}

// Entry
int		main (int argc, char *argv[])
{
	WIN32_FIND_DATA findData;
	HANDLE find;
	unsigned short modelIDs[65536];
	const char *names[65536];
	const char *txdNames[65536];
	unsigned short usNames = 0;
	unsigned short usTxdNames = 0;
	unsigned int n;
	FILE *pLuaFile;
#if (MAP_METHOD==MAP_XML)
	FILE *pMapFile;
#endif
	FILE *pLuaServer;
	FILE *pMetaFile;
	instanceList_t::iterator iter;
	char buffer[1024];
	char copyBuffer[1024];
	CINI *config = LoadINI("config.ini");
	CINI::Entry *mainEntry;

	if (config && (mainEntry = config->GetEntry("Main")))
	{
		// Apply configuration
		usXoffset = mainEntry->GetInt("xOffset");
		usYoffset = mainEntry->GetInt("yOffset");
		usZoffset = mainEntry->GetInt("zOffset");
	}
	
	// Reset the IDs
	for (n=0; n < 65536; n++)
		avalID[n] = false;

	// We change into ipl directory
	SetCurrentDirectory("ipl\\");

	numIPL = 0;
	numIDE = 0;

	// We scan through all ipl files and load em
	if ((find = FindFirstFile("*.ipl", &findData)) == INVALID_HANDLE_VALUE)
		return EXIT_FAILURE;

	LoadTargetIPL(findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadTargetIPL(findData.cFileName);

	FindClose(find);

#ifndef _SAME_NAME_METHOD
	// Now proceed through all .ide files
	if ((find = FindFirstFile("*.ide", &findData)) == INVALID_HANDLE_VALUE)
		return EXIT_FAILURE;

	LoadTargetIDE(findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadTargetIDE(findData.cFileName);

	FindClose(find);
#endif

	// We must get all replacable IDE model ids
	SetCurrentDirectory("..\\rplide");

	if ((find = FindFirstFile("*.ide", &findData)) == INVALID_HANDLE_VALUE)
		return EXIT_FAILURE;

	LoadReplaceIDE (findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadReplaceIDE(findData.cFileName);

	FindClose(find);

	// Set up the directory sheme
	CreateDirectory("..\\output", NULL);

	SetCurrentDirectory("..\\output");

	CreateDirectory("models", NULL);
	CreateDirectory("textures", NULL);
	CreateDirectory("coll", NULL);

	// Create the .lua file
	pLuaFile=fopen("script.lua","w");
	pMetaFile=fopen("meta.xml","w");
#if (MAP_METHOD==MAP_XML)
	pMapFile=fopen("gta3.map","w");
#endif
	pLuaServer=fopen("main_server.lua","w");

	// Init files first
	fwrite(pLuaHeader, 1, strlen(pLuaHeader), pLuaFile);
	fprintf(pMetaFile, pMetaHeader);
	fprintf(pLuaServer,pServerHeader);
#if (MAP_METHOD==MAP_XML)
	fprintf(pMetaFile,pMetaHeaderMap);
	fwrite(pMapHeader,1,strlen(pMapHeader),pMapFile);
#elif (MAP_METHOD==MAP_LUA)
	fprintf(pLuaServer,pServerMapHeader);
#endif
#if (MODEL_METHOD==MODEL_TABLE)
	fprintf(pLuaFile,pLuaModelTableBegin);
#endif
#if (LUA_DOCOMPILE==TRUE)
	fprintf(pMetaFile, pMetaHeader2, "script.luac");
#else
	fprintf(pMetaFile, pMetaHeader2, "script.lua");
#endif

	for (iter = instances.begin(); iter != instances.end(); iter++)
	{
		unsigned short m=0;
		const char *name = (*iter)->m_name;
		const char *txdName;
		char lodBuffer[128];
		CObject *txdObj;

		for (m=0; m < usNames; m++)
		{
			if (strcmp(name, names[m]) == 0)
				break;
		}
		if (m != usNames)
		{
#if (MAP_METHOD==MAP_XML)
			// We add all map entries
			fprintf(pMapFile, pMapEntry, name, modelIDs[m], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
			fprintf(pMapFile, pMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#elif (MAP_METHOD==MAP_LUA)
			// Yup, we script our elements
			fprintf(pLuaServer, pServerMapEntry, name, modelIDs[m], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
			fprintf(pLuaServer, pServerMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#endif
			continue;
		}

		// Copy the model file
		_snprintf(buffer, 1023, "..\\resources\\%s.dff", name);

		if (!FileExists(buffer))
		{
			printf("error: model missing (%s))\n", buffer);
			continue;
		}

		_snprintf(copyBuffer, 1023, "..\\output\\models\\%s.dff", name);

		if (CopyFile(buffer, copyBuffer, true))
			printf("copying model '%s'\n", name);

		// Now the collision
		_snprintf(buffer, 1023, "..\\resources\\%s.col", name);

		if (!FileExists(buffer))
		{
			printf("error: collision missing (%s))\n", buffer);
			continue;
		}

		_snprintf(copyBuffer, 1023, "..\\output\\coll\\%s.col", name);

		if (CopyFile(buffer, copyBuffer, true))
			printf("copying collision '%s'\n", name);

		// Assign the ID
		names[usNames] = name;

		for (m=0; m<65534; m++)
		{
			if (avalID[m])
			{
				avalID[m]=FALSE;
				break;
			}
		}
		if (m == 65534)
		{
			printf("Fatal Error: Not enough ids to convert\n");

			getchar();
			return EXIT_FAILURE;
		}

		modelIDs[usNames++] = m;

#if (MODEL_METHOD==MODEL_TABLE)
		if (iter != instances.begin())
			fprintf(pLuaFile, pLuaModelTableSeperator);
#endif

#if (MAP_METHOD==MAP_XML)
		// We add all map entries
		fprintf(pMapFile, pMapEntry, name, m, (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
		fprintf(pMapFile, pMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#elif (MAP_METHOD==MAP_LUA)
		// Yup, we script our elements
		fprintf(pLuaServer, pServerMapEntry, name, m, (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
		fprintf(pLuaServer, pServerMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#endif

		txdObj = GetObjectByModel(name);

		if (txdObj)
		{
			unsigned int k;

#if (MAP_MAXLOD == FALSE)
			_snprintf(lodBuffer, 127, "%.0f", txdObj->m_drawDistance);
#else
			strcpy(lodBuffer, "500");
#endif

			txdName = txdObj->m_textureName;

			for (k=0; k < usTxdNames; k++)
				if (strcmp(txdNames[k], txdName) == 0)
					break;

			// Little hack
			if (k == usTxdNames)
			{
				// Copy over resources
				_snprintf(buffer, 1023, "..\\resources\\%s.txd", txdName);

				if (!FileExists(buffer))
					printf("texture missing: %s (ignoring)\n", buffer);
				else
				{
					_snprintf(copyBuffer, 1023, "..\\output\\textures\\%s.txd", txdName);

					// Copy the resource over
					if (CopyFile(buffer, copyBuffer, true))
						printf("copying texture '%s'\n", txdName);
				}

				fprintf(pMetaFile, pMetaEntryTXD, name, name, txdName);

				txdNames[usTxdNames++] = txdName;
			}
			else
				fprintf(pMetaFile, pMetaEntry, name, name);
		}
		else
		{
			txdName = "_.txd";
			strcpy(lodBuffer, "500");

			fprintf(pMetaFile, pMetaEntry, name, name);
		}

		// Now LUA
#if (MODEL_METHOD==MODEL_STATIC)
		fprintf(pLuaFile, pLuaEntry, name, m, m, name, m, m, m);
#elif (MODEL_METHOD==MODEL_TABLE)
		fprintf(pLuaFile, pLuaModelTableEntry, m, name, txdName, name, lodBuffer);
#endif
	}
#if (MODEL_METHOD==MODEL_TABLE)
	// We need to write the model loader
	fprintf(pLuaFile,"\n");
	fprintf(pLuaFile,pLuaModelTableEnd);
	fprintf(pLuaFile,pLuaModelTableLoad);
#endif
	// Write end
#if (MAP_METHOD==MAP_XML)
	fprintf(pMapFile,pMapEnd);
#elif (MAP_METHOD==MAP_LUA)
	fprintf(pLuaServer,pServerMapEnd);
#endif
	fprintf(pLuaServer,pServerEnd);
	fprintf(pMetaFile,pMetaEnd);
	fprintf(pLuaFile,pLuaEnd);
	// Close em
	fclose(pLuaFile);
	fclose(pMetaFile);
#if (MAP_METHOD==MAP_XML)
	fclose(pMapFile);
#endif

	SetCurrentDirectory("../");
#if (LUA_DOCOMPILE==TRUE)
	system("luac5.1.exe -o output/script.luac output/script.lua");

	DeleteFile("output/script.lua");
#endif

	// Success
	return EXIT_SUCCESS;
}