/*
	GTA model importer creator for mtasa dm.
	This executable creates files which are needed due to limitation of mtasa dm.
	Created by The_GTA
*/
#include "main.h"

enum eStreamMethod
{
	STREAM_STREAM,
	STREAM_DISTANCE
};

CIPL *ipls[256];
unsigned int numIPL = 0;
CIDE *ides[256];
unsigned int numIDE = 0;
bool modelLOD[65536];
CObject *avalID[65536];
bool mtaBLUE;
unsigned int jetpackHeight;
bool lodSupport;
bool forceLODInherit;
bool staticCompile;
bool cached;
bool debug;
unsigned int streamerMemory;
bool autoCollect;
unsigned int runtimeCorrection;
eStreamMethod streamMethod;

unsigned short modelIDs[65536];
const char *names[65536];
unsigned short usNames = 0;

instanceList_t instances;
objectList_t objects;
objectList_t lod;
lodMap_t lodMap;
std::map <unsigned short, CObject*> backLodMap;
unsigned int tableCount = 0;
unsigned int numAvailable = 0;

short usYoffset=0;
short usXoffset=0;
short usZoffset=500;

#define MAP_LUA 1
#define MAP_XML 2
#define MAP_METHOD MAP_XML
#define MAP_MAXLOD TRUE

#define MODEL_TABLE 1
#define MODEL_STATIC 2
#define MODEL_METHOD MODEL_TABLE

#define LUA_DOCOMPILE TRUE

inline void luaBegin( FILE *file )
{
	fprintf( file, 
		"-- File generated by MTASA model importer\n"
	);

	if ( debug )
	{
		fprintf( file,
			"local modelsLoaded={};\n"
		);
	}

	if ( cached )
	{
		fprintf( file,
			"local streamerMemory=0;\n" \
			"local cached={};\n" \
			"local resourceQueue={};\n"
		);
	}

	fprintf( file,
		"local textureCache = {};\n" \
		"local streamedObjects = {};\n" \
		"local pModels = {};\n\n" \
		"setCloudsEnabled(false);\n"
	);

	if ( !lodSupport )
	{
		fprintf( file,
			"setFarClipDistance(350);\n" \
			"setFogDistance(10);\n"
		);
	}

	fprintf( file,
		"debug.sethook(nil);\n\n"
	);

	// getResourceSize if not cached...?

	fprintf( file,
		"local function getResourceSize(path)\n" \
		"	if not (fileExists(path)) then return 0; end;\n\n" \
		"	local file = fileOpen(path);\n" \
		"	local size = fileGetSize(file)\n\n" \
		"	fileClose(file);\n" \
		"	return size;\n" \
		"end\n\n" \
		"local function requestTexture(model, path)\n" \
		"	local txd = textureCache[path];\n\n" \
		"	if not (txd) then\n"
		"		local size = getResourceSize(path);\n" \
		"		if (size == 0) then return false; end\n\n" \
	);

	if ( cached )
	{
		fprintf( file,
			"		if ( streamerMemory + size > %u ) then\n" \
			"			outputDebugString(\"out of streaming memory! (\"..path..\")\");\n" \
			"			return false;\n" \
			"		end\n\n", streamerMemory
		);
	}

	fprintf( file,
		"		txd = engineLoadTXD(path);\n\n" \
		"		if not (txd) then\n" \
		"			return false;\n" \
		"		end\n\n" \
		"		textureCache[path] = txd;\n"
	);

	if ( cached )
	{
		fprintf( file,
			"		streamerMemory = streamerMemory + size;\n"
		);
	}

	fprintf( file,
		"	end\n" \
		"	return txd;\n" \
		"end\n\n"
	);

	if ( cached )
	{
		fprintf( file,
			"local function loadResources(model, size)\n" \
			"	if not (model.impTxd) then\n" \
			"		engineImportTXD(model.txd, model.id);\n\n" \
			"		model.impTxd = true;\n" \
			"	end\n\n" \
			"	model.model = engineLoadDFF(model.model_file, model.id);\n\n" \
			"	if not (model.model) then return false; end;\n\n"
		);

		if ( lodSupport )
		{
			fprintf( file,
				"	if not (model.col_file) then\n" \
				"		if not (model.super) then return false; end\n\n" \
				"		model.col = pModels[model.super].col;\n" \
				"	else\n" \
				"		model.col = engineLoadCOL(model.col_file, 0);\n\n" \
				"		if not (model.col) then return false; end\n" \
				"	end\n\n"
			);
		}
		else
		{
			fprintf( file, 
				"	model.col = engineLoadCOL(model.col_file, 0);\n\n" \
				"	if not (model.col) then return false; end\n\n"
			);
		}

		fprintf( file,
			"	cached[model.id] = {\n" \
			"		model = model,\n" \
			"		size = size\n" \
			"	};\n" \
			"	resourceQueue[model.id] = nil;\n" \
			"	streamerMemory = streamerMemory + size;\n" \
			"	return true;\n" \
			"end\n\n" \
			"local function freeResources(model)\n" \
			"	local cache = cached[model.id];\n\n" \
			"	if not (cache) then return true; end\n\n" \
			"	if (model.col_file) then\n" \
			"		destroyElement(model.col);\n" \
			"	end\n" \
			"	destroyElement(model.model);\n" \
			"	model.model = nil;\n" \
			"	model.col = nil;\n" \
			"	cached[model.id] = nil;\n" \
			"	streamerMemory = streamerMemory - cache.size;\n" \
			"	return true;\n" \
			"end\n\n" \
			"local function cacheResources(model)\n" \
			"	if (resourceQueue[model.id]) then return false; end\n\n" \
			"	if (cached[model.id]) then return true; end\n\n"
		);

		if ( lodSupport )
		{
			fprintf( file,
				"	local size = getResourceSize(model.model_file);\n" \
				"	if (model.col_file) then\n" \
				"		size = size + getResourceSize(model.col_file);\n" \
				"	end\n"
			);
		}
		else
		{
			fprintf( file,
				"	local size = getResourceSize(model.model_file) + getResourceSize(model.col_file);\n\n"
			);
		}

		fprintf( file,
			"	if ( streamerMemory + size > %u ) then\n" \
			"		outputDebugString(\"streamer memory limit reached... queueing request!\");\n\n" \
			"		resourceQueue[model.id] = {\n" \
			"			size = size,\n" \
			"			model = model\n" \
			"		};\n" \
			"		return false;\n" \
			"	end\n\n" \
			"	return loadResources(model, size);\n" \
			"end\n\n", streamerMemory
		);
	}

	fprintf( file,
		"local function loadModel(model)\n" \
		"	if (model.loaded) then return true; end\n\n"
	);

	if ( lodSupport )
	{
		fprintf( file,
			"	if (model.super) then\n" \
			"		if not (loadModel(pModels[model.super])) then\n" \
			"			return false;\n" \
			"		end\n" \
			"	end\n\n"
		);
	}

	if ( cached )
	{
		fprintf( file,
			"	if not (cacheResources(model)) then return false; end\n\n"
		);
	}

	fprintf( file,
		"	engineReplaceModel(model.model, model.id);\n" \
		"	engineReplaceCOL(model.col, model.id);\n\n" \
		"	model.loaded = true;\n"
	);

	if ( debug )
	{
		fprintf( file,
			"	table.insert(modelsLoaded, model);\n"
		);
	}

	fprintf( file,
		"	return true;\n" \
		"end\n\n" \
		"local function freeModel(model)\n" \
		"	if not (model.loaded) then return true; end\n\n" \
		"	engineRestoreModel(model.id);\n" \
		"	engineRestoreCOL(model.id);\n\n"
	);

	if ( cached && autoCollect )
	{
		fprintf( file,
			"	freeResources(model);\n\n"
		);
	}

	if ( debug )
	{
		fprintf( file,
			"	for m,n in ipairs(modelsLoaded) do\n" \
			"		if (model == n) then\n" \
			"			table.remove(modelsLoaded, m);\n" \
			"			break;\n" \
			"		end\n" \
			"	end\n"
		);
	}

	fprintf( file,
		"	model.loaded = false;\n"
	);

	if ( lodSupport )
	{
		fprintf( file,
			"	if (model.super) then\n" \
			"		return freeModel(pModels[model.super]);\n" \
			"	end\n"
		);
	}

	fprintf( file,
		"end\n\n"
	);
}

inline void luaMethodBegin( FILE *file )
{
	fprintf( file,
		"local function modelStreamOut ()\n" \
		"	local pModel = pModels[getElementModel(source)];\n\n" \
		"	if not (pModel) then return end;\n\n"
	);

	if ( lodSupport )
	{
		fprintf( file,
			"	if (pModel.lodID) then return true; end\n\n"
		);
	}

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file, 
			"	if (pModel.isRequesting == 2) then\n" \
			"		pModel.isRequesting = 1;\n" \
			"		return true;\n" \
			"	elseif (pModel.isRequesting == 3) then\n" \
			"		pModel.isRequesting = 4;\n" \
			"		return true;\n" \
			"	elseif (pModel.isRequesting) then return true; end\n\n"
		);
	}
	
	fprintf( file,
		"	pModel.numStream = pModel.numStream - 1;\n\n" \
		"	if (pModel.numStream == 0) then\n"
	);

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file,
			"		pModel.isRequesting = 3;\n\n"
		);
	}

	fprintf( file,
		"		freeModel(pModel);\n"
	);

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file,
			"\n" \
			"		pModel.isRequesting = false;\n"
		);
	}

	fprintf( file,
		"	end\n" \
		"end\n\n" \
		"local function modelStreamIn ()\n" \
		"	local pModel = pModels[getElementModel(source)];\n\n" \
		"	if not (pModel) then return end;\n\n"
	);

	if ( lodSupport )
	{
		fprintf( file,
			"	if (pModel.lodID) then return true; end\n\n"
		);
	}

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file,
			"	if (pModel.isRequesting == 1) then\n" \
			"		pModel.isRequesting = false;\n" \
			"		return true;\n" \
			"	elseif (pModel.isRequesting) then return true; end\n\n"
		);

		if ( cached && runtimeCorrection )
		{
			fprintf( file,
				"	pModel.requestFrames = %u;\n", runtimeCorrection
			);
		}
	}

	fprintf( file,
		"	pModel.numStream = pModel.numStream + 1;\n\n" \
		"	if not (pModel.numStream == 1) then return true; end\n\n"
	);

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file,
			"	pModel.isRequesting = 2;\n\n"
		);
	}

	fprintf( file,
		"	if not (loadModel(pModel)) then\n" \
		"		setElementInterior(source, 123);\n" \
		"		setElementCollisionsEnabled(source, false);\n" \
		"	end\n"
	);

	if ( streamMethod == STREAM_STREAM )
	{
		fprintf( file,
			"\n" \
			"	if (pModel.isRequesting == 2) then\n" \
			"		outputDebugString(\"invalid model request '\"..pModel.name..\"'\");\n" \
			"		freeModel(pModel);\n" \
			"		pModel.isRequesting = false;\n\n" \
			"		pModel.numStream = 0;\n" \
			"	end\n"
		);
	}

	fprintf( file,
		"end\n\n"
	);
}

inline void luaModelBeginLoader( FILE *file )
{
	fprintf( file,
		"function loadModels ()\n" \
		"	local pModel, pTXD, pColl, pTable;\n\n"
	);
}

inline void luaModelLoadBegin( FILE *file )
{
	if (!staticCompile)
	{
		fprintf( file,
			"	pTable={\n"
		);
	}
}

inline void luaModelLoadEntry( FILE *file, const char *name, const char *txdName, unsigned short id, const char *lod, unsigned short lodID )
{
	if (staticCompile)
	{
		fprintf( file,
			"	pModels[%u]={};\n" \
			"	pTable=pModels[%u];\n" \
			"	pTable.txd=requestTexture(pTable, \"textures/%s.txd\");\n" \
			"	engineImportTXD(pTable.txd, %u);\n", id, id, txdName, id
		);

		if ( cached )
		{
			fprintf( file,
				"	pTable.model_file=\"models/%s.dff\";\n" \
				"	pTable.col_file=\"coll/%s.col\";\n"
			);
		}
		else
		{
			fprintf( file,
				"	pTable.model=engineLoadDFF(\"models/%s.dff\", %u);\n" \
				"	pTable.col=engineLoadCOL(\"coll/%s.col\");\n", name, id, name
			);
		}

		fprintf( file,
			"	pTable.numStream=0;\n" \
			"	pTable.lod=%s;\n" \
			"	pTable.id=%u;\n" \
			"	engineSetModelLODDistance(%u, %s);\n", lod, id, id, lod
		);

		if ( lodSupport && lodID != 0 )
		{
			fprintf( file,
				"\n" \
				"	for m,n in ipairs(getElementsByType(\"object\", resourceRoot)) do\n" \
				"		local x, y, z = getElementPosition(n);\n" \
				"		local rx, ry, rz = getElementRotation(n);\n" \
				"		setLowLODElement(n, createObject(%u, x, y, z, rx, ry, rz, true));\n" \
				"	end\n\n", lodID
			);
		}
	}
	else
	{
		if ( tableCount++ != 0 )
			fprintf( file, ",\n" );

		fprintf( file, 
			"		{ model=%u, model_file=\"%s\", txd_file=\"%s\", coll_file=\"%s\", lod=%s", id, name, txdName, name, lod
		);

		if ( lodSupport && lodID != 0 )
			fprintf( file, ", lodID=%u }", lodID );
		else
			fprintf( file, " }" );
	}
}

inline void luaModelLODBegin( FILE *file )
{
	if ( !staticCompile )
	{
		fprintf( file,
			"	pTable={\n"
		);
	}
}

inline void luaModelLODEntry( FILE *file, unsigned short id, const char *name, const char *colName, const char *txdName, const char *lod, unsigned short super )
{
	if ( !staticCompile )
	{
		if ( tableCount++ != 0 )
			fprintf( file, ",\n" );
		
		fprintf( file,
			"		{ %u, \"%s\", \"%s\", %s, %u", id, name, txdName, lod, super
		);

		if ( colName )
		{
			fprintf( file,
				", \"%s\" }", colName
			);
		}
		else
		{
			fprintf( file,
				" }"
			);
		}
	}
	else
	{
		fprintf( file,
			"	pModels[%u] = {\n" \
			"		id = %u,\n" \
			"		name = %s,\n" \
			"		txd = requestTexture(false, \"textures/%s.txd\"),\n", id, id, name, txdName
		);

		fprintf( file,
			"		numStream = 0,\n" \
			"		lod = %s,\n" \
			"		super = %u\n" \
			"	};\n" \
			"	pModelEntry = pModels[%u];\n", lod, super, id
		);

		if ( cached )
		{
			if ( colName )
			{
				fprintf( file,
					"	pModelEntry.col_file = \"coll/%s.col\";\n", colName
				);
			}

			fprintf( file,
				"	pModelEntry.model_file = \"models/%s.dff\";\n", name
			);
		}
		else
		{
			fprintf( file,
				"	engineImportTXD(pModelEntry.txd, %u);\n" \
				"	pModelEntry.model = engineLoadDFF(\"models/%s.dff\", %u);\n" \
				"	engineReplaceModel(pModelEntry.model, %u);\n", id, name, id, id
			);

			if ( colName )
			{
				fprintf( file,
					"	pModelEntry.col = engineLoadCOL(\"coll/%s.col\");\n" \
					"	engineReplaceCOL(pModelEntry.col, %u);\n", colName, id
				);
			}
		}

		fprintf( file,
			"	engineSetModelLODDistance(%u, %s / 5);\n", id, lod
		);
	}
}

inline void luaModelLODEnd( FILE *file )
{
	if ( !staticCompile )
	{
		fprintf( file,
			"\n" \
			"	};\n\n" \
			"	for m,n in ipairs(pTable) do\n" \
			"		pModels[n[1]] = {\n" \
			"			id = n[1],\n" \
			"			name = n[2],\n" \
			"			txd = requestTexture(false, \"textures/\"..n[3]..\".txd\"),\n" \
			"			numStream = 0,\n" \
			"			lod = n[4] / 5,\n" \
			"			super = n[5]\n" \
			"		};\n" \
			"		pModelEntry = pModels[n[1]];\n"
		);

		if ( cached )
		{
			fprintf( file,
				"		pModelEntry.model_file = \"models/\"..n[2]..\".dff\";\n"
			);

			if ( !forceLODInherit )
			{
				fprintf( file,
					"		if ( #n == 6 ) then\n" \
					"			pModelEntry.col_file = \"coll/\"..n[6]..\".col\";\n" \
					"		end\n"
				);
			}
		}
		else
		{
			fprintf( file,
				"		engineImportTXD(pModelEntry.txd, n[1]);\n" \
				"		pModelEntry.model = engineLoadDFF(\"models/\"..n[2]..\".dff\", n[1]);\n" \
				"		engineReplaceModel(pModelEntry.model, n[1]);\n" \
				"		if ( #n == 6 ) then\n" \
				"			pModelEntry.col = engineLoadCOL(\"coll/\"..n[6]..\".col\");\n" \
				"			engineReplaceCOL(pModelEntry.col, n[1]);\n" \
				"		end\n"
			);
		}

		fprintf( file,
			"		engineSetModelLODDistance(n[1], n[4] / 5);\n" \
			"	end\n"
		);
	}

	fprintf( file, "\n" );

	tableCount = 0;
}

inline void luaModelLoadEnd( FILE *file )
{
	if (!staticCompile)
	{
		fprintf( file,
			"\n" \
			"	};\n\n" \
			"	local n,m;\n\n" \
			"	for n,m in ipairs(pTable) do\n" \
			"		pModels[m.model] = {\n" \
			"			id = m.model,\n" \
			"			name = m.model_file,\n" \
			"			txd = requestTexture(false, \"textures/\"..m.txd_file..\".txd\"),\n" \
			"			numStream = 0,\n" \
			"			lod = m.lod,\n" \
			"			lodID = m.lodID\n" \
			"		};\n" \
			"		pModelEntry = pModels[m.model];\n" \
		);

		if ( cached )
		{
			fprintf( file,
				"		pModelEntry.model_file=\"models/\"..m.model_file..\".dff\";\n" \
				"		pModelEntry.col_file=\"coll/\"..m.coll_file..\".col\";\n" 
			);
		}
		else
		{
			fprintf( file, 
				"		engineImportTXD(pModelEntry.txd, m.model);\n" \
				"		pModelEntry.model=engineLoadDFF(\"models/\"..m.model_file..\".dff\", m.model);\n" \
				"		pModelEntry.col=engineLoadCOL(\"coll/\"..m.coll_file..\".col\");\n"
			);
		}

		fprintf( file,
			"		engineSetModelLODDistance(m.model, m.lod);\n\n"
		);

		if ( lodSupport )
		{
			fprintf( file,
				"		if (m.lodID) then\n" \
				"			for j,k in ipairs(getElementsByType(\"object\", resourceRoot)) do\n" \
				"				if (getElementModel(k) == m.model) then\n" \
				"					local x, y, z = getElementPosition(k);\n" \
				"					local rx, ry, rz = getElementRotation(k);\n" \
				"					setLowLODElement(k, createObject(m.lodID, x, y, z, rx, ry, rz, true));\n" \
				"				end\n" \
				"			end\n" \
				"		end\n"
			);
		}

		fprintf( file,
			"	end\n"
		);
	}

	fprintf( file, 
		"end\n" \
		"loadModels();\n\n"
	);
}

inline void luaMethodEnd( FILE *file )
{
	switch( streamMethod )
	{
	case STREAM_DISTANCE:
		fprintf( file,
			"addEventHandler(\"onClientPreRender\", root, function()\n" \
			"		local m,n;\n" \
			"		local objects = getElementsByType(\"object\", resourceRoot);\n" \
			"		local x, y, z = getCameraMatrix();\n\n" \
			"		for m,n in ipairs(objects) do\n" \
			"			local model = pModels[getElementModel(n)];\n\n" \
			"			if (model) then\n" \
			"				local streamObject = streamedObjects[n];\n" \
			"				local distance = getDistanceBetweenPoints3D(x, y, z, getElementPosition(n));\n\n" \
			"				if not (streamObject) then\n" \
			"					if (distance < model.lod) then\n" \
			"						source = n;\n\n" \
			"						modelStreamIn();\n\n" \
			"						streamedObjects[n] = true;\n" \
			"					end\n" \
			"				elseif (distance > model.lod) then\n" \
			"					source = n;\n\n" \
			"					modelStreamOut();\n\n" \
			"					streamedObjects[n] = nil;\n" \
			"				end\n" \
			"			end\n" \
			"		end\n" \
			"	end\n" \
			");\n\n"
		);
		return;
	case STREAM_STREAM:
		if ( cached && runtimeCorrection )
		{
			fprintf( file,
				"addEventHandler(\"onClientPreRender\", root, function()\n" \
				"		for m,n in pairs(pModels) do\n" \
				"			if (n.isRequesting) then\n" \
				"				n.requestFrames = n.requestFrames - 1;\n\n" \
				"				if (n.requestFrames == 0) then\n" \
				"					n.isRequesting = false;\n"
			);

			if ( debug )
			{
				fprintf( file,
					"					outputDebugString(\"model '\" .. n.name ..\"' timed out\");\n"
				);
			}

			fprintf( file,
				"					freeModel(n);\n" \
				"				end\n" \
				"			end\n" \
				"		end\n" \
				"	end\n" \
				");\n\n"
			);
		}

		fprintf( file,
			"for m,n in ipairs(getElementsByType(\"object\", resourceRoot)) do\n" \
			"	if (isElementStreamedIn(n)) then\n" \
			"		source = n;\n" \
			"		modelStreamIn();\n" \
			"	end\n" \
			"end\n\n" \
			"addEventHandler(\"onClientElementStreamIn\", resourceRoot, function()\n" \
			"		modelStreamIn();\n" \
			"	end\n" \
			");\n" \
			"addEventHandler(\"onClientElementStreamOut\", resourceRoot, function()\n" \
			"		modelStreamOut();\n" \
			"	end\n" \
			");\n\n"
		);
		return;
	}
}

inline void luaEnd( FILE *file )
{
	if ( cached )
	{
		fprintf( file,
			"local function getBiggestCacheObject()\n" \
			"	local obj;\n" \
			"	local size = 0;\n\n" \
			"	for m,n in pairs(cached) do\n" \
			"		if (size < n.size) and not (n.model.loaded) then\n" \
			"			size = n.size;\n" \
			"			obj = n.model;\n" \
			"		end\n" \
			"	end\n" \
			"	return obj, size;\n" \
			"end\n\n" \
			"addEventHandler(\"onClientRender\", root, function()\n" \
			"		local _,request = ({ pairs(resourceQueue) })[1]( resourceQueue );\n" \
			"		if not (request) then return true; end;\n\n" \
			"		while ( streamerMemory + request.size > %u ) do\n" \
			"			local cacheObj = getBiggestCacheObject();\n" \
			"			if not (cacheObj) then\n" \
			"				outputDebugString(\"waiting for cache objects...\");\n" \
			"				return true;\n" \
			"			end\n\n" \
			"			freeResources(cacheObj);\n" \
			"		end\n" \
			"		resourceQueue[request.model.id] = nil;\n\n" \
			"		local model = request.model;\n\n" \
		);

		if ( streamMethod == STREAM_STREAM )
		{
			fprintf( file,
				"		if not ( model.numStream == 0 ) then\n" \
				"			model.isRequesting = 2;\n" \
				"		end\n\n"
			);
		}

		fprintf( file,
			"		if not (loadModel(model)) then return false; end\n\n"
		);

		if ( streamMethod == STREAM_STREAM )
		{
			fprintf( file,
				"		if ( model.isRequesting == 2 ) then\n" \
				"			outputDebugString(\"invalid model request '\" .. model.name ..\"'\");\n" \
				"			freeModel(model);\n" \
				"			model.isRequesting = false;\n\n" \
				"			model.numStream = 0;\n" \
				"		else\n" \
				"			for m,n in ipairs(getElementsByType(\"object\", resourceRoot)) do\n" \
				"				if (getElementModel(n) == model.id) then\n" \
				"					setElementInterior(n, 0);\n" \
				"					setElementCollisionsEnabled(n, true);\n" \
				"				end\n" \
				"			end\n" \
				"		end\n\n"
			);
		}
		else
		{
			fprintf( file,
				"		for m,n in ipairs(getElementsByType(\"object\", resourceRoot)) do\n" \
				"			if (getElementModel(n) == model.id) then\n" \
				"				setElementInterior(n, 0);\n" \
				"				setElementCollisionsEnabled(n, true);\n" \
				"			end\n" \
				"		end\n"
			);
		}

		fprintf( file,
			"	end\n" \
			");\n\n" \
			"addCommandHandler(\"mcollect\", function()\n" \
			"		outputDebugString(\"collecting map garbage...\");\n\n" \
			"		for m,n in pairs(cached) do\n" \
			"			if (n.model.loaded == false) then\n" \
			"				freeResources(n.model);\n" \
			"			end\n" \
			"		end\n" \
			"		collectgarbage();\n" \
			"	end\n" \
			");\n\n" \
			"addCommandHandler(\"mapmem\", function()\n" \
			"		outputChatBox(\"streamer memory: \"..streamerMemory..\" out of %u\");\n" \
			"	end\n" \
			");\n\n", streamerMemory, streamerMemory
		);
	}
	else
	{
		fprintf( file,
			"addEventHandler(\"onClientResourceStop\", resourceRoot, function()\n" \
			"		for m,n in pairs(pModels) do\n" \
			"			if (isElement(n.col)) then destroyElement(n.col); end\n" \
			"			if (isElement(n.model)) then destroyElement(n.model); end\n" \
			"			engineRestoreCOL(m);\n" \
			"			engineRestoreModel(m);\n" \
			"		end\n" \
			"	end\n" \
			");\n\n"
		);
	}

	if ( debug )
	{
		fprintf( file,
			"addEventHandler(\"onClientRender\", root, function()\n" \
			"		local screenX, screenY = guiGetScreenSize();\n"
		);

		if ( cached )
		{
			fprintf( file,
				"		local perc = streamerMemory / %u;\n\n" \
				"		dxDrawText(\"streamerMemory: \" .. streamerMemory .. \" / %u (\" .. math.floor(perc * 100) .. \")\", screenX - 300, screenY - 100);\n" \
				"		dxDrawRectangle(screenX - 300, screenY - 80, 225, 40);\n" \
				"		dxDrawRectangle(screenX - 298, screenY - 78, 221, 36, tocolor(0, 0, 0, 255));\n" \
				"		dxDrawRectangle(screenX - 297, screenY - 77, 219 * perc, 34);\n", streamerMemory, streamerMemory
			);
		}

		fprintf( file,
			"		dxDrawText(\"Models loaded: \" .. #modelsLoaded, screenX - 300, screenY - 120);\n" \
			"		for m,n in ipairs(modelsLoaded) do\n" \
			"			dxDrawText(n.name .. \" (\" .. n.numStream .. \", \" .. tostring(n.isRequesting) .. \")\", 50, 160 + m * 15);\n" \
			"		end\n" \
			"	end\n" \
			");\n\n" \
			"addEventHandler(\"onClientClick\", root, function(button, state, c, d, e, f, g, element)\n" \
			"		if not (button == \"left\") or not (state == \"down\") then return end\n\n" \
			"		if not (element) then return end\n\n" \
			"		local model = pModels[getElementModel(element)];\n\n" \
			"		if not (model) then return end\n\n" \
			"		outputChatBox(\"name: \" .. model.name .. \" (\" .. model.id .. \")\");\n" \
			"	end\n" \
			");\n\n" \
		);
	}

	fprintf( file,
		"collectgarbage();\n" \
		"setJetpackMaxHeight(%u);\n", usZoffset + jetpackHeight
	);
}

const char *pServerHeader=
	"-- Automatically generated server script by MTASA map IPL map converter\n" \
	"setMapName(\"United\");\n";
#if (MAP_METHOD==MAP_LUA)
const char *pServerMapHeader=
	"function loadMap ()\n" \
	"	local pObj;\n\n";
const char *pServerMapEntry=
	"	pObj=createObject(%u,%f,%f,%f);\n" \
	"	setElementID(pObj,\"%s\");\n";
const char *pServerMapEntry2=
	"	setObjectRotation(pObj,%u,%u,%u);\n";
const char *pServerMapEnd=
	"end;\n" \
	"loadMap();\n";
#endif
const char *pServerEnd=
	"-- The end\n";
#if (MAP_METHOD==MAP_XML)
const char *pMapHeader=
	"<map edf:definitions=\"editor_main\">\n";
const char *pMapEntry=
	"	<object id=\"%s\" dimension=\"0\" interior=\"0\" model=\"%u\" posX=\"%f\" posY=\"%f\" posZ=\"%f\" ";
const char *pMapEntry2=
	"rotX=\"%u\" rotY=\"%u\" rotZ=\"%u\" />\n";
char *pMapEnd=
	"</map>\n";
#endif
const char *pMetaHeader=
	"<meta>\n" \
	"	<info author=\"The_GTA\" description=\"Automatically generated map file by MTASA map converter\" version=\"1.2\" type=\"map\" />\n";
#if (MAP_METHOD==MAP_XML)
const char *pMetaHeaderMap=
	"	<map src=\"gta3.map\" />\n";
#endif
const char *pMetaHeader2=
	"	<script src=\"%s\" type=\"client\" />\n" \
	"	<script src=\"main_server.lua\" type=\"server\" />\n";
const char *pMetaEnd=
	"</meta>\n";

bool FileExists(const char *fileName)
{
    return (GetFileAttributes(fileName) != 0xFFFFFFFF);
}

CObject*	GetObjectByModel(const char *model)
{
	objectList_t::iterator iter;

	for (iter = objects.begin(); iter != objects.end(); iter++)
		if (strcmp((*iter)->m_modelName, model) == 0)
			return *iter;
	
	return NULL;
}

// Process data
void	LoadTargetIPL(const char *filename)
{
	unsigned int numInst = 0;
	CIPL *ipl;
	instanceList_t::iterator i_iter;

	ipl = LoadIPL(filename);

	for (i_iter = ipl->m_instances.begin(); i_iter != ipl->m_instances.end(); i_iter++, numInst++)
	{
		if (!lodSupport)
		{
			if (ipl->IsLOD(numInst))
				continue;
		}
		else if ( CInstance *lod = ipl->GetLod( *i_iter ) )
			lodMap[lod->m_modelID] = *i_iter;

		instances.push_back(*i_iter);
	}

	ipls[numIPL++] = ipl;
}

void	LoadTargetIDE(const char *name)
{
	CIDE *ide = LoadIDE(name);
	objectList_t::iterator iter;

	if (!ide)
	{
		printf("could not load '%s' file!", name);
		getchar();

		exit(EXIT_FAILURE);
	}

	for (iter = ide->m_objects.begin(); iter != ide->m_objects.end(); iter++)
	{
		unsigned int m;

		// Assign the ID
		for (m=0; m<65534; m++)
		{
			if ( !avalID[m] )
				continue;
			
			avalID[m] = NULL;
			break;
		}
		if ( m == 65534 )
		{
			printf( "ERROR: requiring more valid model ids\n" );
			
			getchar();
			exit(EXIT_FAILURE);
		}
		(*iter)->m_realModelID = m;
		modelIDs[(*iter)->m_modelID] = m;

		numAvailable--;

		if ( lodSupport )
		{
			//TODO: One lod to multiple objects!
			if ( CInstance *inst = lodMap[(*iter)->m_modelID] )
			{
				lod.push_back(*iter);
				backLodMap[inst->m_modelID] = *iter;
			}
		}

		objects.push_back(*iter);
	}
}

void	LoadReplaceIPL(const char *filename)
{
	CIPL *ipl = LoadIPL(filename);
	instanceList_t::iterator iter;
	unsigned int numInst = 0;

	for ( iter = ipl->m_instances.begin(); iter != ipl->m_instances.end(); iter++, numInst++ )
		modelLOD[(*iter)->m_modelID] = (ipl->IsLOD( numInst ) || (*iter)->m_lod != -1);

	delete ipl;
}

void	LoadReplaceIDE(const char *filename)
{
	CIDE *ide = LoadIDE(filename);
	objectList_t::iterator iter;

	// Marks all ids as available
	for (iter = ide->m_objects.begin(); iter != ide->m_objects.end(); iter++)
	{
		if ((*iter)->m_flags & (OBJECT_GRAFFITI | OBJECT_STATUE | OBJECT_UNKNOWN | OBJECT_UNKNOWN_2 | OBJECT_ALPHA1 | OBJECT_ALPHA2 | OBJECT_BREAKGLASS | OBJECT_BREAKGLASS_CRACK | OBJECT_GARAGE | OBJECT_MULTICLUMP | OBJECT_EXPLOSIVE | OBJECT_VEGETATION | OBJECT_BIG_VEGETATION | OBJECT_UNKNOWN_HIGH))
		//if ((*iter)->m_flags != 0 && !((*iter)->m_flags & OBJECT_INTERIOR))
			continue;

		if (mtaBLUE && modelLOD[(*iter)->m_modelID])
			continue;

		avalID[(*iter)->m_modelID] = *iter;
		numAvailable++;
	}
}

const char *txdNames[65536];
const char *txdName;
const char *colName;
unsigned short usTxdNames = 0;
char lodBuffer[128];
FILE *pMetaFile;

inline bool AllocateResources( const char *name, bool lod )
{
	char buffer[1024];
	char copyBuffer[1024];

	// Copy the model file
	_snprintf(buffer, 1023, "..\\resources\\%s.dff", name);

	if (!FileExists(buffer))
	{
		printf("error: model missing (%s)\n", buffer);
		return false;
	}

	_snprintf(copyBuffer, 1023, "..\\output\\models\\%s.dff", name);

	if (CopyFile(buffer, copyBuffer, true))
		printf("copying model '%s'\n", name);

	if ( !lod || !forceLODInherit )
	{
		// Now the collision
		_snprintf(buffer, 1023, "..\\resources\\%s.col", name);

		if ( !FileExists(buffer) )
		{
			if ( !lod )
			{
				printf("error: collision missing (%s)\n", buffer);
				return false;
			}
		
			colName = NULL;
		}
		else
		{
			colName = name;

			_snprintf(copyBuffer, 1023, "..\\output\\coll\\%s.col", colName);

			if (CopyFile(buffer, copyBuffer, true))
				printf("copying collision '%s'\n", colName);
		}
	}
	else
		colName = NULL;

	names[usNames++] = name;

	CObject *txdObj = GetObjectByModel(name);

	if (txdObj)
	{
		unsigned int k;

		if (lodSupport)
			_snprintf(lodBuffer, 127, "%.0f", txdObj->m_drawDistance);
		else
			strcpy(lodBuffer, "500");

		txdName = txdObj->m_textureName;

		for (k=0; k < usTxdNames; k++)
			if (strcmp(txdNames[k], txdName) == 0)
				break;

		// Little hack
		if (k == usTxdNames)
		{
			// Copy over resources
			_snprintf(buffer, 1023, "..\\resources\\%s.txd", txdName);

			if (!FileExists(buffer))
				printf("texture missing: %s (ignoring)\n", buffer);
			else
			{
				_snprintf(copyBuffer, 1023, "..\\output\\textures\\%s.txd", txdName);

				// Copy the resource over
				if (CopyFile(buffer, copyBuffer, true))
					printf("copying texture '%s'\n", txdName);
			}

			fprintf( pMetaFile,
				"	<file src=\"textures\\%s.txd\" type=\"client\" />\n", txdName
			);

			txdNames[usTxdNames++] = txdName;
		}
	}
	else
	{
		txdName = "_";
		strcpy(lodBuffer, "500");

		printf("could not find object def for '%s'\n", name);
	}

	fprintf( pMetaFile,
		"	<file src=\"models\\%s.dff\" type=\"client\" />\n", name
	);

	if ( colName )
	{
		fprintf( pMetaFile, 
			"	<file src=\"coll\\%s.col\" type=\"client\" />\n", colName
		);
	}

	return true;
}

// Entry
int		main (int argc, char *argv[])
{
	WIN32_FIND_DATA findData;
	HANDLE find;
	unsigned int n;
	FILE *pLuaFile;
#if (MAP_METHOD==MAP_XML)
	FILE *pMapFile;
#endif
	FILE *pLuaServer;
	instanceList_t::iterator iter;
	CINI *config = LoadINI("config.ini");
	CINI::Entry *mainEntry;

	if (config && (mainEntry = config->GetEntry("Main")))
	{
		// Apply configuration
		usXoffset = mainEntry->GetInt("xOffset");
		usYoffset = mainEntry->GetInt("yOffset");
		usZoffset = mainEntry->GetInt("zOffset");
		mtaBLUE = mainEntry->GetBool("mtaBLUE");
		jetpackHeight = (unsigned int)mainEntry->GetInt("jetpackHeight");
		lodSupport = mainEntry->GetBool("lodSupport");
		forceLODInherit = mainEntry->GetBool("forceLODInherit");
		staticCompile = mainEntry->GetBool("static");
		cached = mainEntry->GetBool("cached");
		streamerMemory = (unsigned int)mainEntry->GetInt("streamerMemory") * 1024 * 1024;
		debug = mainEntry->GetBool("debug");
		autoCollect = mainEntry->GetBool("autoCollect");
		runtimeCorrection = (unsigned int)mainEntry->GetInt("runtimeCorrection");

		const char *method = mainEntry->Get("method");

		if ( strcmp(method, "stream") == 0 )
		{
			streamMethod = STREAM_STREAM;

			printf( "WARNING: This method might not work with asynchronous loading\n" );
		}
		else if ( strcmp(method, "distance") == 0 )
			streamMethod = STREAM_DISTANCE;
		else
		{
			printf( "Invalid streaming method; defaulting to stream\n" );

			streamMethod = STREAM_STREAM;

			goto nonotify;
		}

		if (lodSupport)
			printf( "WARNING: Compiling with lod support does not guarrante an error-free mainworld\n" );

		printf( "Using StreamingMethod: %s\n", method );
	}
	else
	{
		// Default disabled
		mtaBLUE = false;
		jetpackHeight = 1000;
		lodSupport = false;
		forceLODInherit = true;
		staticCompile = false;
		cached = false;
		debug = false;
		autoCollect = false;
		runtimeCorrection = true;
	}

nonotify:
	if (mtaBLUE)
		printf( "Compiling with MTA:BLUE support...\n" );
	
	// Reset the IDs
	for (n=0; n < 65536; n++)
		avalID[n] = NULL;

	numIPL = 0;
	numIDE = 0;

	if (mtaBLUE)
	{
		memset( modelLOD, 0, sizeof(modelLOD) );

		// Load all GTA:SA static scene objects (hack)
		SetCurrentDirectory("rplipl\\");

		if ((find = FindFirstFile("*.ipl", &findData)) == INVALID_HANDLE_VALUE)
		{
			printf("Error: Could not find any GTA:SA item placement information (rplipl/.ipl)\n");

			getchar();
			return EXIT_FAILURE;
		}

		LoadReplaceIPL( findData.cFileName );

		while (FindNextFile( find, &findData ))
			LoadReplaceIPL( findData.cFileName );

		FindClose( find );

		SetCurrentDirectory("..");
	}

	// We must get all replacable IDE model ids
	SetCurrentDirectory("rplide\\");

	if ((find = FindFirstFile("*.ide", &findData)) == INVALID_HANDLE_VALUE)
	{
		printf( "ERROR: Could not find GTA:SA model definitions" );

		getchar();
		return EXIT_FAILURE;
	}

	LoadReplaceIDE (findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadReplaceIDE(findData.cFileName);

	FindClose(find);

	// We change into ipl directory
	SetCurrentDirectory("..\\ipl\\");

	// We scan through all ipl files and load em
	if ((find = FindFirstFile("*.ipl", &findData)) == INVALID_HANDLE_VALUE)
	{
		printf( "ERROR: Could not find any item placement files (ipl/.ipl)" );

		getchar();
		return EXIT_FAILURE;
	}

	LoadTargetIPL(findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadTargetIPL(findData.cFileName);

	FindClose(find);

	// Now proceed through all .ide files
	if ((find = FindFirstFile("*.ide", &findData)) == INVALID_HANDLE_VALUE)
	{
		printf( "ERROR: Could not find any model definitions (ipl/.ide)\n" );

		getchar();
		return EXIT_FAILURE;
	}

	LoadTargetIDE(findData.cFileName);

	while (FindNextFile(find, &findData))
		LoadTargetIDE(findData.cFileName);

	FindClose(find);

	// Set up the directory scheme
	CreateDirectory("..\\output", NULL);

	SetCurrentDirectory("..\\output");

	CreateDirectory("models", NULL);
	CreateDirectory("textures", NULL);
	CreateDirectory("coll", NULL);

	// Create the .lua file
	pLuaFile=fopen("script.lua","w");
	pMetaFile=fopen("meta.xml","w");
#if (MAP_METHOD==MAP_XML)
	pMapFile=fopen("gta3.map","w");
#endif
	pLuaServer=fopen("main_server.lua","w");

	// Init files first
	luaBegin( pLuaFile );
	fprintf(pMetaFile, pMetaHeader);
	fprintf(pLuaServer,pServerHeader);
#if (MAP_METHOD==MAP_XML)
	fprintf(pMetaFile,pMetaHeaderMap);
	fwrite(pMapHeader,1,strlen(pMapHeader),pMapFile);
#elif (MAP_METHOD==MAP_LUA)
	fprintf(pLuaServer,pServerMapHeader);
#endif

	luaMethodBegin( pLuaFile );

	luaModelBeginLoader( pLuaFile );

#if (LUA_DOCOMPILE==TRUE)
	fprintf(pMetaFile, pMetaHeader2, "script.luac");
#else
	fprintf(pMetaFile, pMetaHeader2, "script.lua");
#endif

	if ( lodSupport )
	{
		objectList_t::iterator objIter;

		// LODs are loaded and stay this way
		luaModelLODBegin( pLuaFile );

		for ( objIter = lod.begin(); objIter != lod.end(); objIter++ )
		{
			unsigned int m;
			const char *name = (*objIter)->m_modelName;

			for (m=0; m<usNames; m++)
			{
				if (strcmp(names[m], name) == 0)
					break;
			}
			if (m != usNames)
				continue;

			if ( !AllocateResources( (*objIter)->m_modelName, true ) )
				continue;

			_snprintf( lodBuffer, 127, "%.0f", (*objIter)->m_drawDistance );

			luaModelLODEntry( pLuaFile, (*objIter)->m_realModelID, (*objIter)->m_modelName, colName, (*objIter)->m_textureName, lodBuffer, GetObjectByModel( lodMap[(*objIter)->m_modelID]->m_name )->m_realModelID );
		}

		luaModelLODEnd( pLuaFile );
	}

	luaModelLoadBegin( pLuaFile );

	for (iter = instances.begin(); iter != instances.end(); iter++)
	{
		unsigned short m;
		const char *name = (*iter)->m_name;

		if ( lodSupport && lodMap[(*iter)->m_modelID] )
			continue;

		for (m=0; m < usNames; m++)
		{
			if (strcmp(name, names[m]) == 0)
				break;
		}
		if (m != usNames)
		{
#if (MAP_METHOD==MAP_XML)
			// We add all map entries
			fprintf(pMapFile, pMapEntry, name, modelIDs[(*iter)->m_modelID], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
			fprintf(pMapFile, pMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#elif (MAP_METHOD==MAP_LUA)
			// Yup, we script our elements
			fprintf(pLuaServer, pServerMapEntry, name, modelIDs[(*iter)->m_modelID], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
			fprintf(pLuaServer, pServerMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#endif
			continue;
		}

		if ( !AllocateResources( name, false ) )
			continue;

#if (MAP_METHOD==MAP_XML)
		// We add all map entries
		fprintf(pMapFile, pMapEntry, name, modelIDs[(*iter)->m_modelID], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
		fprintf(pMapFile, pMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#elif (MAP_METHOD==MAP_LUA)
		// Yup, we script our elements
		fprintf(pLuaServer, pServerMapEntry, name, modelIDs[(*iter)->m_modelID], (*iter)->m_position[0] + usXoffset, (*iter)->m_position[1] + usYoffset, (*iter)->m_position[2] + usZoffset);
		fprintf(pLuaServer, pServerMapEntry2, (int)(*iter)->m_rotation[0], (int)(*iter)->m_rotation[1], (int)(*iter)->m_rotation[2]);
#endif

		unsigned short lod = 0;

		if ( CObject *lodObj = backLodMap[(*iter)->m_modelID] )
			lod = lodObj->m_realModelID;

		// Now LUA
		luaModelLoadEntry( pLuaFile, name, txdName, modelIDs[(*iter)->m_modelID], lodBuffer, lod );
	}
	
	luaModelLoadEnd( pLuaFile );

#if (MAP_METHOD==MAP_XML)
	fprintf(pMapFile, pMapEnd);
#elif (MAP_METHOD==MAP_LUA)
	fprintf(pLuaServer, pServerMapEnd);
#endif

	luaMethodEnd( pLuaFile );

	fprintf(pLuaServer, pServerEnd);
	fprintf(pMetaFile, pMetaEnd);
	luaEnd( pLuaFile );
	// Close em
	fclose(pLuaFile);
	fclose(pMetaFile);
#if (MAP_METHOD==MAP_XML)
	fclose(pMapFile);
#endif

	SetCurrentDirectory("../");
#if (LUA_DOCOMPILE==TRUE)
	system("luac5.1.exe -s -o output/script.luac output/script.lua");

	DeleteFile("output/script.lua");
#endif

	// Success
	return EXIT_SUCCESS;
}